<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 凸透鏡成像模擬</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Tailwind for simple UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1A1B20;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #E2E8F0;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #E2E8F0;
            padding: 10px 24px;
            cursor: pointer;
            border-radius: 9999px;
            /* Pill shape */
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-weight: 500;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .instruction {
            background-color: rgba(26, 27, 32, 0.8);
            padding: 20px;
            border-radius: 16px;
            max-width: 320px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
        }

        .highlight-text {
            color: #FFBF00;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 191, 0, 0.5);
        }
    </style>
</head>

<body>

    <div id="info">
        <div class="instruction">
            <h1 class="text-2xl mb-3 font-bold text-white tracking-wide">凸透鏡成像實驗</h1>
            <div class="space-y-2">
                <p class="text-sm text-gray-300 flex items-start">
                    <span class="mr-2 opacity-70">1.</span>
                    <span>拖曳樹上的 <span class="highlight-text">發光點</span>。</span>
                </p>
                <p class="text-sm text-gray-300 flex items-start">
                    <span class="mr-2 opacity-70">2.</span>
                    <span>觀察高亮度的光路變化。</span>
                </p>
                <p class="text-sm text-gray-300 flex items-start">
                    <span class="mr-2 opacity-70">3.</span>
                    <span>琥珀金代表樹幹光，螢光綠代表樹葉光。</span>
                </p>
            </div>
        </div>
    </div>

    <div id="controls">
        <button class="btn" id="resetBtn">重設屏幕</button>
    </div>

    <script>
        // --- 全域變數 ---
        let scene, camera, renderer, controls;
        let treePlane, imageTreePlane, lens, screenMesh;
        let sourceLightPoint, sourceGlow; // 新增 glow
        let axisLine, imagingLine;

        let obliqueCone1, obliqueCone2;

        // 畫布紋理相關
        let screenCanvas, screenCtx, screenTexture;
        let treeContextData;

        // 互動相關
        let raycaster, mouse;
        let isDragging = false;

        // 參數設定
        const LENS_Z = 0;
        const OBJECT_Z = 15; // 物距
        const IMAGE_Z = -15; // 像距
        const LENS_RADIUS = 4;

        // --- 配色方案 (Color Palette) ---
        const COLORS = {
            bg: 0x1A1B20,           // 深灰藍背景
            trunkLight: 0xFFBF00,   // 琥珀金 (High Contrast)
            leafLight: 0x00FF41,    // 螢光綠 (Neon Green)
            lensTint: 0xAACCFF,     // 透鏡冰藍色
            screenBase: 0xFFFFFF,   // 屏幕基底
            grid: 0x4A5568          // 輔助線顏色
        };

        /**
         * 自定義「斜圓錐」類別 (視覺優化版)
         * 特點：包含低透明度的填充(Mesh) 與 高亮度的邊框(Lines)
         */
        class ObliqueConeMesh {
            constructor(lensCenter, lensRadius, color) {
                this.lensCenter = lensCenter;
                this.lensRadius = lensRadius;
                this.segments = 64;
                this.color = new THREE.Color(color);

                // 1. 填充網格 (Fill Mesh) - 低透明度
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.segments * 3 * 3);
                this.baseVertices = [];

                // 預計算底座圓周
                for (let i = 0; i <= this.segments; i++) {
                    const theta = (i / this.segments) * Math.PI * 2;
                    const x = Math.cos(theta) * lensRadius + lensCenter.x;
                    const y = Math.sin(theta) * lensRadius + lensCenter.y;
                    const z = lensCenter.z;
                    this.baseVertices.push(new THREE.Vector3(x, y, z));
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const fillMaterial = new THREE.MeshBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.0, // 初始隱藏
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending // 光線疊加變亮
                });

                this.mesh = new THREE.Mesh(geometry, fillMaterial);
                this.mesh.frustumCulled = false;

                // 2. 邊框線條 (Stroke Lines) - 高透明度
                // 包含：底座圓圈 + 8條從尖端射出的光束線
                const lineGeometry = new THREE.BufferGeometry();
                // 預估頂點數：圓周(segments+1) + 8條光束(每條2點)
                const lineCount = (this.segments + 1) + (8 * 2);
                const linePositions = new Float32Array(lineCount * 3);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));

                const lineMaterial = new THREE.LineBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.0,
                    blending: THREE.AdditiveBlending,
                    linewidth: 1 // WebGL 限制通常為 1，但靠顏色亮度補償
                });

                this.lines = new THREE.LineSegments(lineGeometry, lineMaterial);
                this.lines.frustumCulled = false;
            }

            addTo(scene) {
                scene.add(this.mesh);
                scene.add(this.lines);
            }

            updateTip(tipPosition) {
                // A. 更新填充網格
                const positions = this.mesh.geometry.attributes.position.array;
                let ptr = 0;
                for (let i = 0; i < this.segments; i++) {
                    // Triangle: Tip -> Base_i -> Base_i+1
                    positions[ptr++] = tipPosition.x; positions[ptr++] = tipPosition.y; positions[ptr++] = tipPosition.z;

                    const vBase1 = this.baseVertices[i];
                    positions[ptr++] = vBase1.x; positions[ptr++] = vBase1.y; positions[ptr++] = vBase1.z;

                    const vBase2 = this.baseVertices[i + 1];
                    positions[ptr++] = vBase2.x; positions[ptr++] = vBase2.y; positions[ptr++] = vBase2.z;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;

                // B. 更新線條 (Stroke)
                const linePos = this.lines.geometry.attributes.position.array;
                let lPtr = 0;

                // 1. 底座圓圈 (用 LineSegments 模擬 LineLoop: i->i+1)
                for (let i = 0; i < this.segments; i++) {
                    const v1 = this.baseVertices[i];
                    const v2 = this.baseVertices[i + 1];

                    linePos[lPtr++] = v1.x; linePos[lPtr++] = v1.y; linePos[lPtr++] = v1.z;
                    linePos[lPtr++] = v2.x; linePos[lPtr++] = v2.y; linePos[lPtr++] = v2.z;
                }

                // 2. 光束射線 (Ray Lines) - 每隔 8 個 segment 畫一條
                const rayInterval = Math.floor(this.segments / 8);
                for (let i = 0; i < this.segments; i += rayInterval) {
                    const vBase = this.baseVertices[i];
                    // Tip -> Base
                    linePos[lPtr++] = tipPosition.x; linePos[lPtr++] = tipPosition.y; linePos[lPtr++] = tipPosition.z;
                    linePos[lPtr++] = vBase.x; linePos[lPtr++] = vBase.y; linePos[lPtr++] = vBase.z;
                }

                this.lines.geometry.attributes.position.needsUpdate = true;
            }

            setOpacity(opacity) {
                // 填充透明度較低 (約 20% 的輸入值)
                this.mesh.material.opacity = opacity * 0.2;
                // 線條透明度較高 (約 100% 的輸入值，讓邊框清晰)
                this.lines.material.opacity = opacity;
            }

            setColor(hexColor) {
                this.color.setHex(hexColor);
                this.mesh.material.color.setHex(hexColor);
                this.lines.material.color.setHex(hexColor);
            }
        }

        init();
        animate();

        function init() {
            // 1. 場景設置
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.bg);
            scene.fog = new THREE.FogExp2(COLORS.bg, 0.012);

            // 2. 相機
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 15, 25);
            camera.lookAt(0, 0, 0);

            // 3. 渲染器 (高品質)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // 開啟 sRGB 編碼以獲得更正確的顏色顯示
            renderer.outputEncoding = THREE.sRGBEncoding;

            // 陰影設定
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.body.appendChild(renderer.domElement);

            // 4. 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 60;

            // 5. 燈光 (調整為更有氛圍的燈光)
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            // 主光 (冷色調)
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            // 補光 (暖色調，增加層次)
            const pointLight = new THREE.PointLight(0x6688cc, 0.5);
            pointLight.position.set(-20, 10, -20);
            scene.add(pointLight);

            // --- 建立物體 ---

            // A. 鏡軸 (優化線條質感)
            const axisGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, OBJECT_Z + 10),
                new THREE.Vector3(0, 0, IMAGE_Z - 10)
            ]);
            const axisMat = new THREE.LineDashedMaterial({
                color: COLORS.grid,
                dashSize: 0.5,
                gapSize: 0.5,
                opacity: 0.4,
                transparent: true
            });
            axisLine = new THREE.Line(axisGeo, axisMat);
            axisLine.computeLineDistances();
            scene.add(axisLine);

            // B. 凸透鏡 (玻璃質感優化)
            const lensGeo = new THREE.CylinderGeometry(LENS_RADIUS, LENS_RADIUS, 0.6, 64);
            lensGeo.rotateX(Math.PI / 2);
            const lensMat = new THREE.MeshPhysicalMaterial({
                color: COLORS.lensTint,
                metalness: 0.0,
                roughness: 0.0,
                transmission: 0.95, // 極高透光
                thickness: 2.0,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                envMapIntensity: 1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });
            lens = new THREE.Mesh(lensGeo, lensMat);
            lens.position.set(0, 0, LENS_Z);
            scene.add(lens);

            // 透鏡邊框 (金屬感)
            const rimGeo = new THREE.TorusGeometry(LENS_RADIUS, 0.15, 16, 100);
            const rimMat = new THREE.MeshStandardMaterial({
                color: 0x8899AA,
                metalness: 0.8,
                roughness: 0.2
            });
            const rim = new THREE.Mesh(rimGeo, rimMat);
            lens.add(rim);

            // C. 物體 (樹木)
            treePlane = createProceduralTreePlane();
            treePlane.position.set(0, 1, OBJECT_Z);
            scene.add(treePlane);

            // D. 屏幕 (磨砂玻璃質感)
            createScreenMesh();

            // E. 光源點 (燈泡發光效果)
            // 核心實體
            const lightGeo = new THREE.SphereGeometry(0.2, 32, 32);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            sourceLightPoint = new THREE.Mesh(lightGeo, lightMat);
            sourceLightPoint.visible = false;
            sourceLightPoint.renderOrder = 999;
            scene.add(sourceLightPoint);

            // 光暈 (Glow Sprite)
            const glowMap = createGlowTexture();
            const glowMat = new THREE.SpriteMaterial({
                map: glowMap,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            sourceGlow = new THREE.Sprite(glowMat);
            sourceGlow.scale.set(3, 3, 1); // 光暈比實體大
            sourceLightPoint.add(sourceGlow); // 綁定在光點上

            // G. 光錐 (使用新類別)
            obliqueCone1 = new ObliqueConeMesh(new THREE.Vector3(0, 0, LENS_Z), LENS_RADIUS, COLORS.trunkLight);
            obliqueCone1.addTo(scene);

            obliqueCone2 = new ObliqueConeMesh(new THREE.Vector3(0, 0, LENS_Z), LENS_RADIUS, COLORS.trunkLight);
            obliqueCone2.addTo(scene);

            // H. 成像輔助線 (更細緻)
            const imagingLineGeo = new THREE.BufferGeometry();
            imagingLineGeo.setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
            const imagingLineMat = new THREE.LineDashedMaterial({
                color: 0xFFFFFF,
                dashSize: 0.2,
                gapSize: 0.2,
                opacity: 0.3,
                transparent: true,
                depthWrite: false
            });
            imagingLine = new THREE.Line(imagingLineGeo, imagingLineMat);
            scene.add(imagingLine);

            // I. 倒立樹的像 (Ghost Image)
            imageTreePlane = treePlane.clone();
            imageTreePlane.material = treePlane.material.clone();
            imageTreePlane.material.color.setHex(0xFFFFFF);
            imageTreePlane.material.depthWrite = false;
            imageTreePlane.material.opacity = 0.25;
            imageTreePlane.material.blending = THREE.AdditiveBlending; // 讓像看起來像投影光
            imageTreePlane.renderOrder = 2; // 確保最後繪製

            imageTreePlane.position.set(0, -1, IMAGE_Z);
            imageTreePlane.rotation.z = Math.PI;
            imageTreePlane.position.z = IMAGE_Z + 0.1;
            scene.add(imageTreePlane);

            // 初始化互動
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('mouseleave', onMouseUp, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchend', onMouseUp, false);
            renderer.domElement.addEventListener('touchcancel', onMouseUp, false);

            document.getElementById('resetBtn').addEventListener('click', clearScreen);
        }

        // 創建發光紋理
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createProceduralTreePlane() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, 1024, 2048);

            // 1. 樹幹 (使用更飽和的顏色以配合發光)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(472, 1200, 80, 600);

            // 2. 樹葉 (深綠色，作為基底)
            ctx.fillStyle = '#116611';

            // 下層
            ctx.beginPath();
            ctx.moveTo(212, 1200); ctx.lineTo(812, 1200); ctx.lineTo(512, 600);
            ctx.fill();

            // 中層
            ctx.fillStyle = '#228822';
            ctx.beginPath();
            ctx.moveTo(272, 800); ctx.lineTo(752, 800); ctx.lineTo(512, 300);
            ctx.fill();

            // 上層
            ctx.fillStyle = '#33AA33';
            ctx.beginPath();
            ctx.moveTo(332, 400); ctx.lineTo(692, 400); ctx.lineTo(512, 0);
            ctx.fill();

            treeContextData = ctx.getImageData(0, 0, 1024, 2048);

            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            // sRGB 編碼
            texture.encoding = THREE.sRGBEncoding;

            const geometry = new THREE.PlaneGeometry(6, 12);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide,
                alphaTest: 0.1
            });

            const plane = new THREE.Mesh(geometry, material);
            return plane;
        }

        function createScreenMesh() {
            screenCanvas = document.createElement('canvas');
            screenCanvas.width = 1024;
            screenCanvas.height = 1024;
            screenCtx = screenCanvas.getContext('2d');

            clearScreen();

            screenTexture = new THREE.CanvasTexture(screenCanvas);
            screenTexture.minFilter = THREE.LinearFilter;
            screenTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            screenTexture.encoding = THREE.sRGBEncoding;

            const geometry = new THREE.PlaneGeometry(20, 20);
            // 磨砂質感屏幕: 使用 MeshPhysicalMaterial 模擬
            // 這裡為了保持 Canvas 繪圖可見，我們使用混合方案：
            // MeshBasicMaterial 負責顯示繪圖內容，但調整透明度
            const material = new THREE.MeshBasicMaterial({
                map: screenTexture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.95, // 稍微不透，讓白色背景明顯
                depthWrite: false
            });

            screenMesh = new THREE.Mesh(geometry, material);
            screenMesh.renderOrder = 1;
            screenMesh.position.set(0, 0, IMAGE_Z);
            scene.add(screenMesh);
        }

        function clearScreen() {
            if (!screenCtx) return;
            // 磨砂玻璃色：微帶灰藍的半透明白
            screenCtx.fillStyle = 'rgba(240, 245, 255, 0.2)';
            screenCtx.clearRect(0, 0, screenCanvas.width, screenCanvas.height);
            screenCtx.fillRect(0, 0, screenCanvas.width, screenCanvas.height);

            // 邊框
            screenCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            screenCtx.lineWidth = 20;
            screenCtx.strokeRect(0, 0, screenCanvas.width, screenCanvas.height);

            if (screenTexture) screenTexture.needsUpdate = true;
        }

        // --- 互動邏輯 ---

        function updateLightInteraction(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(treePlane);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const uv = hit.uv;

                const pixelX = Math.floor(uv.x * 1024);
                const pixelY = Math.floor((1 - uv.y) * 2048);

                if (pixelX >= 0 && pixelX < 1024 && pixelY >= 0 && pixelY < 2048) {
                    const index = (pixelY * 1024 + pixelX) * 4;
                    const r = treeContextData.data[index];
                    const g = treeContextData.data[index + 1];
                    const alpha = treeContextData.data[index + 3];

                    if (alpha > 20) {
                        const point = hit.point;

                        sourceLightPoint.visible = true;
                        sourceLightPoint.position.copy(point);
                        sourceLightPoint.position.z = OBJECT_Z - 0.2;

                        // 顏色判斷 (High Contrast)
                        let coneHex = COLORS.trunkLight;
                        // 如果 G 明顯大於 R，判定為樹葉
                        if (g > r + 20) {
                            coneHex = COLORS.leafLight;
                        }

                        // 更新光點 Glow 顏色
                        sourceGlow.material.color.setHex(coneHex);

                        // 光源 -> 透鏡
                        obliqueCone1.updateTip(sourceLightPoint.position);
                        obliqueCone1.setColor(coneHex);

                        // 像的位置
                        const imageX = -point.x;
                        const imageY = -point.y;
                        const imagePos = new THREE.Vector3(imageX, imageY, IMAGE_Z);

                        // 透鏡 -> 像
                        obliqueCone2.updateTip(imagePos);
                        obliqueCone2.setColor(coneHex);

                        imagingLine.geometry.setFromPoints([sourceLightPoint.position, imagePos]);
                        imagingLine.computeLineDistances();
                        imagingLine.visible = true;

                        if (isDragging) {
                            // 拖曳時：光路清晰
                            obliqueCone1.setOpacity(1.0); // 傳入 1.0，內部會轉為 20% fill, 100% stroke
                            obliqueCone2.setOpacity(1.0);
                            paintOnScreen(imageX, imageY, coneHex);
                        } else {
                            // 懸停時：光路微亮
                            obliqueCone1.setOpacity(0.4);
                            obliqueCone2.setOpacity(0.4);
                        }
                        return true;
                    }
                }
            }

            sourceLightPoint.visible = false;
            obliqueCone1.setOpacity(0.0);
            obliqueCone2.setOpacity(0.0);
            imagingLine.visible = false;
            return false;
        }

        function paintOnScreen(worldX, worldY, colorHex) {
            const canvasX = ((worldX + 10) / 20) * screenCanvas.width;
            const canvasY = (1 - (worldY + 10) / 20) * screenCanvas.height;

            const ctx = screenCtx;
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 12, 0, Math.PI * 2);

            const r = (colorHex >> 16) & 255;
            const g = (colorHex >> 8) & 255;
            const b = colorHex & 255;

            // 使用 Lighter 模式讓顏色疊加更亮
            ctx.globalCompositeOperation = 'screen'; // 或 lighter
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.15)`; // 低透明度疊加
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over'; // 還原

            screenTexture.needsUpdate = true;
        }

        // --- 事件處理 ---

        function onMouseDown(event) {
            event.preventDefault();
            const interacted = updateLightInteraction(event.clientX, event.clientY);
            if (interacted) {
                isDragging = true;
                controls.enabled = false;
            }
        }

        function onMouseMove(event) {
            event.preventDefault();
            updateLightInteraction(event.clientX, event.clientY);
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                updateLightInteraction(event.touches[0].clientX, event.touches[0].clientY);
            }
        }

        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                const interacted = updateLightInteraction(
                    event.touches[0].clientX,
                    event.touches[0].clientY
                );
                if (interacted) {
                    isDragging = true;
                    controls.enabled = false;
                }
            }
        }

        function onMouseUp(event) {
            isDragging = false;
            controls.enabled = true;
            updateLightInteraction(-1000, -1000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // 讓光暈永遠面向相機 (雖然 Sprite 預設就是這樣，但確保萬一)
            if (sourceLightPoint.visible) {
                // 簡單的 pulse 動畫
                const scale = 3 + Math.sin(Date.now() * 0.005) * 0.2;
                sourceGlow.scale.set(scale, scale, 1);
            }

            renderer.render(scene, camera);
        }

    </script>
</body>

</html>