<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 凸透鏡成像模擬</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Tailwind for simple UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1A1B20;
        }

        #info {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            /* 讓點擊穿透空白區域 */
            display: flex;
            justify-content: center;
            z-index: 10;
        }

        .instruction {
            background-color: rgba(26, 27, 32, 0.85);
            padding: 8px 24px;
            border-radius: 0 0 16px 16px;
            /* 下方圓角 */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: none;
            backdrop-filter: blur(12px);
            pointer-events: auto;

            /* 文字排版設定 */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 12px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 13px;
            /* 較小的字體 */
            color: #E2E8F0;
            line-height: 1.5;
            text-align: center;
        }

        .title-text {
            font-weight: bold;
            color: #FFFFFF;
            font-size: 14px;
            margin-right: 4px;
        }

        .separator {
            color: rgba(255, 255, 255, 0.2);
            font-size: 10px;
        }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #E2E8F0;
            padding: 10px 24px;
            cursor: pointer;
            border-radius: 9999px;
            /* Pill shape */
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-weight: 500;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .highlight-text {
            color: #FFBF00;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(255, 191, 0, 0.4);
        }
    </style>
</head>

<body>

    <div id="info">
        <div class="instruction">
            <span class="title-text">凸透鏡成像實驗</span>
            <span class="separator">|</span>
            <span>1. 拖曳樹上的 <span class="highlight-text">發光點</span></span>
            <span class="separator">|</span>
            <span>2. 觀察高亮度的光路變化</span>
            <span class="separator">|</span>
            <span>3. 琥珀金代表樹幹光，螢光綠代表樹葉光</span>
        </div>
    </div>

    <div id="controls">
        <button class="btn" id="resetBtn">重設視角</button>
    </div>

    <script>
        // --- 全域變數 ---
        let scene, camera, renderer, controls;
        let treePlane, imageTreePlane, lens, screenMesh;
        let sourceLightPoint, sourceGlow;
        let axisLine, imagingLine;

        let obliqueCone1, obliqueCone2;

        // 畫布紋理相關
        let screenCanvas, screenCtx, screenTexture;
        let treeContextData;

        // 互動相關
        let raycaster, mouse;
        let isDragging = false;

        // 參數設定
        const LENS_Z = 0;
        const OBJECT_Z = 15; // 物距
        const IMAGE_Z = -15; // 像距
        const LENS_RADIUS = 4;

        // --- 配色方案 (Color Palette) ---
        const COLORS = {
            bg: 0x1A1B20,           // 深灰藍背景
            trunkLight: 0xFFBF00,   // 琥珀金 (High Contrast)
            leafLight: 0x00FF41,    // 螢光綠 (Neon Green)
            lensTint: 0xAACCFF,     // 透鏡冰藍色
            screenBase: 0xFFFFFF,   // 屏幕基底
            grid: 0x4A5568          // 輔助線顏色
        };

        /**
         * 自定義「斜圓錐」類別 (視覺優化版)
         */
        class ObliqueConeMesh {
            constructor(lensCenter, lensRadius, color) {
                this.lensCenter = lensCenter;
                this.lensRadius = lensRadius;
                this.segments = 64;
                this.color = new THREE.Color(color);

                // 1. 填充網格 (Fill Mesh) - 低透明度
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.segments * 3 * 3);
                this.baseVertices = [];

                // 預計算底座圓周
                for (let i = 0; i <= this.segments; i++) {
                    const theta = (i / this.segments) * Math.PI * 2;
                    const x = Math.cos(theta) * lensRadius + lensCenter.x;
                    const y = Math.sin(theta) * lensRadius + lensCenter.y;
                    const z = lensCenter.z;
                    this.baseVertices.push(new THREE.Vector3(x, y, z));
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const fillMaterial = new THREE.MeshBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.0, // 初始隱藏
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.mesh = new THREE.Mesh(geometry, fillMaterial);
                this.mesh.frustumCulled = false;

                // 2. 邊框線條 (Stroke Lines) - 高透明度
                const lineGeometry = new THREE.BufferGeometry();
                const lineCount = (this.segments + 1) + (8 * 2);
                const linePositions = new Float32Array(lineCount * 3);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));

                const lineMaterial = new THREE.LineBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.0,
                    blending: THREE.AdditiveBlending,
                    linewidth: 1
                });

                this.lines = new THREE.LineSegments(lineGeometry, lineMaterial);
                this.lines.frustumCulled = false;
            }

            addTo(scene) {
                scene.add(this.mesh);
                scene.add(this.lines);
            }

            updateTip(tipPosition) {
                // A. 更新填充網格
                const positions = this.mesh.geometry.attributes.position.array;
                let ptr = 0;
                for (let i = 0; i < this.segments; i++) {
                    // Triangle: Tip -> Base_i -> Base_i+1
                    positions[ptr++] = tipPosition.x; positions[ptr++] = tipPosition.y; positions[ptr++] = tipPosition.z;

                    const vBase1 = this.baseVertices[i];
                    positions[ptr++] = vBase1.x; positions[ptr++] = vBase1.y; positions[ptr++] = vBase1.z;

                    const vBase2 = this.baseVertices[i + 1];
                    positions[ptr++] = vBase2.x; positions[ptr++] = vBase2.y; positions[ptr++] = vBase2.z;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;

                // B. 更新線條 (Stroke)
                const linePos = this.lines.geometry.attributes.position.array;
                let lPtr = 0;

                // 1. 底座圓圈
                for (let i = 0; i < this.segments; i++) {
                    const v1 = this.baseVertices[i];
                    const v2 = this.baseVertices[i + 1];

                    linePos[lPtr++] = v1.x; linePos[lPtr++] = v1.y; linePos[lPtr++] = v1.z;
                    linePos[lPtr++] = v2.x; linePos[lPtr++] = v2.y; linePos[lPtr++] = v2.z;
                }

                // 2. 光束射線
                const rayInterval = Math.floor(this.segments / 8);
                for (let i = 0; i < this.segments; i += rayInterval) {
                    const vBase = this.baseVertices[i];
                    linePos[lPtr++] = tipPosition.x; linePos[lPtr++] = tipPosition.y; linePos[lPtr++] = tipPosition.z;
                    linePos[lPtr++] = vBase.x; linePos[lPtr++] = vBase.y; linePos[lPtr++] = vBase.z;
                }

                this.lines.geometry.attributes.position.needsUpdate = true;
            }

            setOpacity(opacity) {
                this.mesh.material.opacity = opacity * 0.2;
                this.lines.material.opacity = opacity;
            }

            setColor(hexColor) {
                this.color.setHex(hexColor);
                this.mesh.material.color.setHex(hexColor);
                this.lines.material.color.setHex(hexColor);
            }
        }

        init();
        animate();

        function init() {
            // 1. 場景設置
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.bg);
            scene.fog = new THREE.FogExp2(COLORS.bg, 0.012);

            // 2. 相機
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 15, 25);
            camera.lookAt(0, 0, 0);

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.body.appendChild(renderer.domElement);

            // 4. 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 60;

            // 5. 燈光
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            const pointLight = new THREE.PointLight(0x6688cc, 0.5);
            pointLight.position.set(-20, 10, -20);
            scene.add(pointLight);

            // --- 建立物體 ---

            // A. 鏡軸
            const axisGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, OBJECT_Z + 10),
                new THREE.Vector3(0, 0, IMAGE_Z - 10)
            ]);
            const axisMat = new THREE.LineDashedMaterial({
                color: COLORS.grid,
                dashSize: 0.5,
                gapSize: 0.5,
                opacity: 0.4,
                transparent: true
            });
            axisLine = new THREE.Line(axisGeo, axisMat);
            axisLine.computeLineDistances();
            scene.add(axisLine);

            // B. 凸透鏡
            const lensGeo = new THREE.CylinderGeometry(LENS_RADIUS, LENS_RADIUS, 0.6, 64);
            lensGeo.rotateX(Math.PI / 2);
            const lensMat = new THREE.MeshPhysicalMaterial({
                color: COLORS.lensTint,
                metalness: 0.0,
                roughness: 0.0,
                transmission: 0.95,
                thickness: 2.0,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                envMapIntensity: 1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });
            lens = new THREE.Mesh(lensGeo, lensMat);
            lens.position.set(0, 0, LENS_Z);
            scene.add(lens);

            const rimGeo = new THREE.TorusGeometry(LENS_RADIUS, 0.15, 16, 100);
            const rimMat = new THREE.MeshStandardMaterial({
                color: 0x8899AA,
                metalness: 0.8,
                roughness: 0.2
            });
            const rim = new THREE.Mesh(rimGeo, rimMat);
            lens.add(rim);

            // C. 物體 (樹木)
            treePlane = createProceduralTreePlane();
            treePlane.position.set(0, 1, OBJECT_Z);
            scene.add(treePlane);

            // D. 屏幕
            createScreenMesh();

            // E. 光源點
            const lightGeo = new THREE.SphereGeometry(0.2, 32, 32);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            sourceLightPoint = new THREE.Mesh(lightGeo, lightMat);
            sourceLightPoint.visible = false;
            sourceLightPoint.renderOrder = 999;
            scene.add(sourceLightPoint);

            const glowMap = createGlowTexture();
            const glowMat = new THREE.SpriteMaterial({
                map: glowMap,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            sourceGlow = new THREE.Sprite(glowMat);
            sourceGlow.scale.set(3, 3, 1);
            sourceLightPoint.add(sourceGlow);

            // G. 光錐
            obliqueCone1 = new ObliqueConeMesh(new THREE.Vector3(0, 0, LENS_Z), LENS_RADIUS, COLORS.trunkLight);
            obliqueCone1.addTo(scene);

            obliqueCone2 = new ObliqueConeMesh(new THREE.Vector3(0, 0, LENS_Z), LENS_RADIUS, COLORS.trunkLight);
            obliqueCone2.addTo(scene);

            // H. 成像輔助線
            const imagingLineGeo = new THREE.BufferGeometry();
            imagingLineGeo.setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
            const imagingLineMat = new THREE.LineDashedMaterial({
                color: 0xFFFFFF,
                dashSize: 0.2,
                gapSize: 0.2,
                opacity: 0.3,
                transparent: true,
                depthWrite: false
            });
            imagingLine = new THREE.Line(imagingLineGeo, imagingLineMat);
            scene.add(imagingLine);

            // I. 倒立樹的像
            imageTreePlane = treePlane.clone();
            imageTreePlane.material = treePlane.material.clone();
            imageTreePlane.material.color.setHex(0xFFFFFF);
            imageTreePlane.material.depthWrite = false;
            imageTreePlane.material.opacity = 0.25;
            imageTreePlane.material.blending = THREE.AdditiveBlending;
            imageTreePlane.renderOrder = 2;

            imageTreePlane.position.set(0, -1, IMAGE_Z);
            imageTreePlane.rotation.z = Math.PI;
            imageTreePlane.position.z = IMAGE_Z + 0.1;
            scene.add(imageTreePlane);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('mouseleave', onMouseUp, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchend', onMouseUp, false);
            renderer.domElement.addEventListener('touchcancel', onMouseUp, false);

            document.getElementById('resetBtn').addEventListener('click', resetCamera);
        }

        // 重設視角的函式
        function resetCamera() {
            camera.position.set(25, 15, 25);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createProceduralTreePlane() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, 1024, 2048);

            // 1. 樹幹
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(472, 1200, 80, 600);

            // 2. 樹葉
            ctx.fillStyle = '#116611';

            ctx.beginPath();
            ctx.moveTo(212, 1200); ctx.lineTo(812, 1200); ctx.lineTo(512, 600);
            ctx.fill();

            ctx.fillStyle = '#228822';
            ctx.beginPath();
            ctx.moveTo(272, 800); ctx.lineTo(752, 800); ctx.lineTo(512, 300);
            ctx.fill();

            ctx.fillStyle = '#33AA33';
            ctx.beginPath();
            ctx.moveTo(332, 400); ctx.lineTo(692, 400); ctx.lineTo(512, 0);
            ctx.fill();

            treeContextData = ctx.getImageData(0, 0, 1024, 2048);

            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.encoding = THREE.sRGBEncoding;

            const geometry = new THREE.PlaneGeometry(6, 12);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide,
                alphaTest: 0.1
            });

            const plane = new THREE.Mesh(geometry, material);
            return plane;
        }

        function createScreenMesh() {
            screenCanvas = document.createElement('canvas');
            screenCanvas.width = 1024;
            screenCanvas.height = 1024;
            screenCtx = screenCanvas.getContext('2d');

            clearScreen();

            screenTexture = new THREE.CanvasTexture(screenCanvas);
            screenTexture.minFilter = THREE.LinearFilter;
            screenTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            screenTexture.encoding = THREE.sRGBEncoding;

            const geometry = new THREE.PlaneGeometry(20, 20);
            const material = new THREE.MeshBasicMaterial({
                map: screenTexture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.95,
                depthWrite: false
            });

            screenMesh = new THREE.Mesh(geometry, material);
            screenMesh.renderOrder = 1;
            screenMesh.position.set(0, 0, IMAGE_Z);
            scene.add(screenMesh);
        }

        function clearScreen() {
            if (!screenCtx) return;
            screenCtx.fillStyle = 'rgba(240, 245, 255, 0.2)';
            screenCtx.clearRect(0, 0, screenCanvas.width, screenCanvas.height);
            screenCtx.fillRect(0, 0, screenCanvas.width, screenCanvas.height);

            screenCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            screenCtx.lineWidth = 20;
            screenCtx.strokeRect(0, 0, screenCanvas.width, screenCanvas.height);

            if (screenTexture) screenTexture.needsUpdate = true;
        }

        function updateLightInteraction(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(treePlane);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const uv = hit.uv;

                const pixelX = Math.floor(uv.x * 1024);
                const pixelY = Math.floor((1 - uv.y) * 2048);

                if (pixelX >= 0 && pixelX < 1024 && pixelY >= 0 && pixelY < 2048) {
                    const index = (pixelY * 1024 + pixelX) * 4;
                    const r = treeContextData.data[index];
                    const g = treeContextData.data[index + 1];
                    const alpha = treeContextData.data[index + 3];

                    if (alpha > 20) {
                        const point = hit.point;

                        sourceLightPoint.visible = true;
                        sourceLightPoint.position.copy(point);
                        sourceLightPoint.position.z = OBJECT_Z - 0.2;

                        let coneHex = COLORS.trunkLight;
                        if (g > r + 20) {
                            coneHex = COLORS.leafLight;
                        }

                        sourceGlow.material.color.setHex(coneHex);

                        obliqueCone1.updateTip(sourceLightPoint.position);
                        obliqueCone1.setColor(coneHex);

                        const imageX = -point.x;
                        const imageY = -point.y;
                        const imagePos = new THREE.Vector3(imageX, imageY, IMAGE_Z);

                        obliqueCone2.updateTip(imagePos);
                        obliqueCone2.setColor(coneHex);

                        imagingLine.geometry.setFromPoints([sourceLightPoint.position, imagePos]);
                        imagingLine.computeLineDistances();
                        imagingLine.visible = true;

                        if (isDragging) {
                            obliqueCone1.setOpacity(1.0);
                            obliqueCone2.setOpacity(1.0);
                            paintOnScreen(imageX, imageY, coneHex);
                        } else {
                            obliqueCone1.setOpacity(0.4);
                            obliqueCone2.setOpacity(0.4);
                        }
                        return true;
                    }
                }
            }

            sourceLightPoint.visible = false;
            obliqueCone1.setOpacity(0.0);
            obliqueCone2.setOpacity(0.0);
            imagingLine.visible = false;
            return false;
        }

        function paintOnScreen(worldX, worldY, colorHex) {
            const canvasX = ((worldX + 10) / 20) * screenCanvas.width;
            const canvasY = (1 - (worldY + 10) / 20) * screenCanvas.height;

            const ctx = screenCtx;
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 12, 0, Math.PI * 2);

            const r = (colorHex >> 16) & 255;
            const g = (colorHex >> 8) & 255;
            const b = colorHex & 255;

            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.15)`;
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';

            screenTexture.needsUpdate = true;
        }

        function onMouseDown(event) {
            event.preventDefault();
            const interacted = updateLightInteraction(event.clientX, event.clientY);
            if (interacted) {
                isDragging = true;
                controls.enabled = false;
            }
        }

        function onMouseMove(event) {
            event.preventDefault();
            updateLightInteraction(event.clientX, event.clientY);
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                updateLightInteraction(event.touches[0].clientX, event.touches[0].clientY);
            }
        }

        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                const interacted = updateLightInteraction(
                    event.touches[0].clientX,
                    event.touches[0].clientY
                );
                if (interacted) {
                    isDragging = true;
                    controls.enabled = false;
                }
            }
        }

        function onMouseUp(event) {
            isDragging = false;
            controls.enabled = true;
            updateLightInteraction(-1000, -1000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (sourceLightPoint.visible) {
                const scale = 3 + Math.sin(Date.now() * 0.005) * 0.2;
                sourceGlow.scale.set(scale, scale, 1);
            }

            renderer.render(scene, camera);
        }

    </script>
</body>

</html>