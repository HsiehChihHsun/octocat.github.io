<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>點點煙火</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
            /* 防止移動端觸控滾動 */
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-family: "Noto Sans TC", sans-serif;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>

<body>

    <div id="instructions">點擊畫面施放更多煙火</div>
    <canvas id="canvas"></canvas>

    <script>
        // 初始化 Canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let cw = window.innerWidth;
        let ch = window.innerHeight;

        canvas.width = cw;
        canvas.height = ch;

        // 監聽視窗大小改變
        window.addEventListener('resize', () => {
            cw = window.innerWidth;
            ch = window.innerHeight;
            canvas.width = cw;
            canvas.height = ch;
        });

        // 配置參數
        const CONFIG = {
            rocketSpeed: 12,        // 煙火升空基礎速度
            particleCount: 150,     // 爆炸粒子數量
            explosionSpeed: 6,      // 爆炸擴散基礎力度
            hueStart: 0,            // 顏色循環起始
            slowMotionScale: 0.1,   // 慢動作倍率 (1/10)
            normalScale: 1.0,       // 正常倍率
        };

        // 儲存煙火與粒子的陣列
        let fireworks = [];
        let particles = [];

        // 輔助函數：產生範圍亂數
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // 輔助函數：計算兩點距離
        function calculateDistance(p1x, p1y, p2x, p2y) {
            let xDistance = p1x - p2x;
            let yDistance = p1y - p2y;
            return Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));
        }

        // 煙火 (Rocket) 類別：負責升空階段
        class Firework {
            constructor(sx, sy, tx, ty) {
                this.x = sx;
                this.y = sy;
                this.sx = sx;
                this.sy = sy;
                this.tx = tx;
                this.ty = ty;
                this.distanceToTarget = calculateDistance(sx, sy, tx, ty);
                this.distanceTraveled = 0;

                // 計算角度與速度
                this.angle = Math.atan2(ty - sy, tx - sx);
                this.speed = CONFIG.rocketSpeed;
                this.acceleration = 1.05; // 升空加速感
                this.brightness = random(50, 70);
                this.targetRadius = 1;

                // 當前顏色
                this.hue = CONFIG.hueStart;

                // 軌跡
                this.coordinates = [];
                this.coordinateCount = 3;
                while (this.coordinateCount--) {
                    this.coordinates.push([this.x, this.y]);
                }
            }

            update(index) {
                // 升空階段保持正常速度 (normalScale)，以免等待太久
                const timeScale = CONFIG.normalScale;

                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);

                // 閃爍目標點
                if (this.targetRadius < 8) {
                    this.targetRadius += 0.3 * timeScale;
                } else {
                    this.targetRadius = 1;
                }

                this.speed *= this.acceleration;

                let vx = Math.cos(this.angle) * this.speed * timeScale;
                let vy = Math.sin(this.angle) * this.speed * timeScale;

                this.distanceTraveled = calculateDistance(this.sx, this.sy, this.x + vx, this.y + vy);

                if (this.distanceTraveled >= this.distanceToTarget) {
                    // 到達目標，產生爆炸
                    createParticles(this.tx, this.ty, this.hue);
                    fireworks.splice(index, 1);
                } else {
                    this.x += vx;
                    this.y += vy;
                }
            }

            draw() {
                ctx.beginPath();
                // 繪製尾跡
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = 'hsl(' + this.hue + ', 100%, ' + this.brightness + '%)';
                ctx.stroke();

                ctx.beginPath();
                // 繪製目標點提示
                ctx.arc(this.tx, this.ty, this.targetRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // 粒子 (Particle) 類別：負責爆炸階段
        class Particle {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;

                // 軌跡
                this.coordinates = [];
                this.coordinateCount = 5;
                while (this.coordinateCount--) {
                    this.coordinates.push([this.x, this.y]);
                }

                // 隨機擴散角度
                this.angle = random(0, Math.PI * 2);
                // 初始速度
                this.speed = random(1, CONFIG.explosionSpeed);

                // 物理屬性
                this.friction = 0.96;  // 空氣阻力
                this.gravity = 1.2;    // 重力

                this.hue = random(hue - 20, hue + 20);
                this.brightness = random(50, 80);
                this.alpha = 1;

                // 衰減速度 (決定存活時間)
                // 為了配合慢動作，這裡的基礎衰減率設得很低，然後會在 update 中再乘上 slowMotionScale
                this.decay = random(0.01, 0.02);
            }

            update(index) {
                // *** 關鍵修改：應用慢動作時間縮放 ***
                const timeScale = CONFIG.slowMotionScale;

                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);

                // 物理模擬計算
                // 速度隨著摩擦力減慢
                // 注意：摩擦力是指數級的，但在簡單模擬中，我們將其視為每幀的損耗
                // 為了在慢動作下正確模擬摩擦力，我們調整速度的改變量
                this.speed *= (1 - (1 - this.friction) * timeScale);

                // 計算位移 (速度 * 時間)
                this.x += Math.cos(this.angle) * this.speed * timeScale;
                this.y += Math.sin(this.angle) * this.speed * timeScale + (this.gravity * timeScale); // 重力也受時間影響，表現為緩慢下墜

                // 透明度衰減 (壽命)
                this.alpha -= this.decay * timeScale;

                if (this.alpha <= this.decay * timeScale) {
                    particles.splice(index, 1);
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = 'hsla(' + this.hue + ', 100%, ' + this.brightness + '%, ' + this.alpha + ')';
                ctx.stroke();
            }
        }

        function createParticles(x, y, hue) {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                particles.push(new Particle(x, y, hue));
            }
        }

        // 主循環
        function loop() {
            requestAnimationFrame(loop);

            // 隨時間改變顏色基調
            CONFIG.hueStart += 0.5;

            // 拖尾效果：使用半透明黑色覆蓋畫布，且透明度極低以適應慢動作
            // 慢動作時物體移動距離短，如果清除得太快，軌跡會消失
            // 所以這裡使用 globalCompositeOperation 技巧或較低的 opacity
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; // 稍微增加一點清除力道，保持畫面乾淨
            ctx.fillRect(0, 0, cw, ch);

            // 設為 lighter 可以讓重疊的粒子發光
            ctx.globalCompositeOperation = 'lighter';

            // 更新並繪製所有煙火
            let i = fireworks.length;
            while (i--) {
                fireworks[i].draw();
                fireworks[i].update(i);
            }

            // 更新並繪製所有粒子
            let j = particles.length;
            while (j--) {
                particles[j].draw();
                particles[j].update(j);
            }

            // 自動施放邏輯
            if (timerTick >= timerTotal) {
                if (!mousedown) {
                    // 自動發射
                    // 修改：先決定目標座標，再從該目標的 X 軸正下方發射
                    let targetX = random(0, cw);
                    let targetY = random(0, ch / 2);
                    fireworks.push(new Firework(targetX, ch, targetX, targetY));
                    timerTick = 0;
                }
            } else {
                timerTick++;
            }

            // 限制滑鼠連點頻率
            if (limiterTick >= limiterTotal) {
                if (mousedown) {
                    // 修改：從滑鼠點擊位置的正下方 (mx, ch) 發射到點擊位置 (mx, my)
                    fireworks.push(new Firework(mx, ch, mx, my));
                    limiterTick = 0;
                }
            } else {
                limiterTick++;
            }
        }

        // 控制變數
        let timerTotal = 80;
        let timerTick = 0;
        let limiterTotal = 5;
        let limiterTick = 0;
        let mousedown = false;
        let mx, my;

        // 滑鼠/觸控事件
        canvas.addEventListener('mousemove', function (e) {
            mx = e.clientX;
            my = e.clientY;
        });

        canvas.addEventListener('mousedown', function (e) {
            e.preventDefault();
            mousedown = true;
            mx = e.clientX;
            my = e.clientY;
        });

        canvas.addEventListener('mouseup', function (e) {
            e.preventDefault();
            mousedown = false;
        });

        // 觸控支援
        canvas.addEventListener('touchstart', function (e) {
            e.preventDefault();
            mousedown = true;
            mx = e.touches[0].clientX;
            my = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', function (e) {
            e.preventDefault();
            mousedown = false;
        });

        // 啟動
        window.onload = loop;

    </script>
</body>

</html>